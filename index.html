<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>ì˜ë‹¨ì–´ OCR í†µí•© ë°©ì‹</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
<style>
body { font-family: sans-serif; padding:20px; }
.word { font-weight:bold; color:#003399; margin-top:8px; font-size:18px; }
.mean { color:#444; margin-bottom:12px; font-size:15px; }
</style>
</head>
<body>

<h2>ğŸ“š ì˜ì–´ ë‹¨ì–´ OCR ìë™ì¶”ì¶œ (ì¢Œí‘œ+í…ìŠ¤íŠ¸ ë°©ì‹ í†µí•©)</h2>
<input type="file" id="file" accept="image/*"><br><br>
<button onclick="run()">ì¶”ì¶œ</button>
<div id="log"></div>
<div id="output"></div>
<button id="saveBtn" style="display:none">CSV ì €ì¥</button>

<script>
// í•œêµ­ì–´ ë¹„ìœ¨
function korRatio(s){const m=s.match(/[ê°€-í£]/g);return m?m.length/s.length:0;}
// ì˜ì–´ ë‹¨ì–´ íŒë‹¨
function isWord(s){return /^[A-Za-z][A-Za-z\-]{2,18}$/.test(s);}

async function run(){
  const file=document.getElementById("file").files[0];
  if(!file){ alert("ì´ë¯¸ì§€ ì„ íƒí•˜ì„¸ìš”"); return; }

  document.getElementById("log").innerText="â³ ë¶„ì„ ì¤‘...";

  const {data:{words}} = await Tesseract.recognize(file,"eng+kor",{
    logger:m=>{if(m.status)document.getElementById("log").innerText=m.status;}
  });

  // OCR ë°•ìŠ¤ ì •ë¦¬
  let boxes = words.map(w=>({
    text: w.text.trim(),
    x: w.bbox.x0, y: w.bbox.y0,
    h: w.bbox.y1 - w.bbox.y0
  })).filter(b=>b.text);

  const avgH = boxes.reduce((s,b)=>s+b.h,0)/boxes.length;

  // Step1) ì™¼ìª½ì— í¬ê³  ì˜ì–´ = í—¤ë“œì›Œë“œ í›„ë³´
  let heads = boxes.filter(b=>b.h > avgH*1.2 && isWord(b.text) && b.x < 500);

  let results = [];

  for(let hw of heads){
    // Step2) í…ìŠ¤íŠ¸ ì¤„ ê¸°ì¤€ë„ ë™ì‹œì— ìˆ˜í–‰ â†’ í†µí•© ì ìˆ˜ ê³„ì‚°
    let near = boxes.filter(b => b.y > hw.y && b.y < hw.y + avgH*10);

    let best = null, bestScore = 0;

    for(let cand of near){
      const text = cand.text;

      // ì˜ë¯¸ ì¡°ê±´
      const isKoreanMeaning = korRatio(text) > 0.3 && !/[A-Za-z]{3,}/.test(text);

      if(!isKoreanMeaning) continue;

      // ê±°ë¦¬ ì ìˆ˜(ê°€ê¹Œìš¸ìˆ˜ë¡ ë†’ìŒ)
      const dy = cand.y - hw.y;
      const distScore = Math.max(0, (300 - dy)) / 300;

      // í…ìŠ¤íŠ¸ ì˜ë¯¸ ì ìˆ˜
      const textScore = korRatio(text);

      // ì´ ì ìˆ˜: ê±°ë¦¬ + í•œêµ­ì–´ ë¹„ìœ¨
      const score = distScore*0.5 + textScore*0.5;

      if(score > bestScore){
        bestScore = score;
        best = cand;
      }
    }

    if(best){
      results.push({
        word: hw.text.toLowerCase(),
        meaning: best.text.replace(/^(\d+\.|\Â·|\-)\s*/,"")
      });
    }
  }

  // ì¤‘ë³µ ì œê±°
  const uniq = Array.from(new Map(results.map(v=>[v.word,v])).values());

  // ì¶œë ¥
  let out="";
  uniq.forEach(v=>{
    out+=`<div class="word">${v.word}</div><div class="mean">${v.meaning}</div>`;
  });

  document.getElementById("output").innerHTML = out || "âŒ ë‹¨ì–´ ì—†ìŒ";
  document.getElementById("log").innerText="âœ… ì™„ë£Œ";

  if(uniq.length>0){
    const btn=document.getElementById("saveBtn");
    btn.style.display="inline-block";
    btn.onclick = ()=>{
      let csv="word,meaning\n";
      uniq.forEach(v=>csv+=`${v.word},"${v.meaning}"\n`);
      const blob=new Blob([csv],{type:"text/csv"});
      const a=document.createElement("a");
      a.href=URL.createObjectURL(blob);
      a.download="vocab.csv";
      a.click();
    };
  }
}
</script>

</body>
</html>
